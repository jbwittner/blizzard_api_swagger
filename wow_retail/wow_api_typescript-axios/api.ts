/* tslint:disable */
/* eslint-disable */
/**
 * Swagger BLIZZARD Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.5.6
 * Contact: jeanbaptiste.wittner@outlook.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Array of media asset
 * @export
 * @interface ArrayAssetData
 */
export interface ArrayAssetData {
    /**
     * 
     * @type {Array<AssetData>}
     * @memberof ArrayAssetData
     */
    'assets'?: Array<AssetData>;
}
/**
 * Array of classes index
 * @export
 * @interface ArrayClassesIndexData
 */
export interface ArrayClassesIndexData {
    /**
     * 
     * @type {Array<IndexData>}
     * @memberof ArrayClassesIndexData
     */
    'classes': Array<IndexData>;
}
/**
 * Array of covenant index
 * @export
 * @interface ArrayCovenantIndexData
 */
export interface ArrayCovenantIndexData {
    /**
     * 
     * @type {Array<IndexData>}
     * @memberof ArrayCovenantIndexData
     */
    'covenants'?: Array<IndexData>;
}
/**
 * Array of races index
 * @export
 * @interface ArrayRacesIndexData
 */
export interface ArrayRacesIndexData {
    /**
     * 
     * @type {Array<IndexData>}
     * @memberof ArrayRacesIndexData
     */
    'races': Array<IndexData>;
}
/**
 * Array of classes index
 * @export
 * @interface ArrayRealmsIndexData
 */
export interface ArrayRealmsIndexData {
    /**
     * 
     * @type {Array<RealmIndexData>}
     * @memberof ArrayRealmsIndexData
     */
    'realms': Array<RealmIndexData>;
}
/**
 * Array of specializations index
 * @export
 * @interface ArraySpecializationsIndexData
 */
export interface ArraySpecializationsIndexData {
    /**
     * 
     * @type {Array<IndexData>}
     * @memberof ArraySpecializationsIndexData
     */
    'character_specializations': Array<IndexData>;
}
/**
 * Asset of media
 * @export
 * @interface AssetData
 */
export interface AssetData {
    /**
     * Type of media
     * @type {string}
     * @memberof AssetData
     */
    'key': AssetDataKeyEnum;
    /**
     * Uri of the media
     * @type {string}
     * @memberof AssetData
     */
    'value': string;
    /**
     * File id
     * @type {number}
     * @memberof AssetData
     */
    'file_data_id': number;
}

export const AssetDataKeyEnum = {
    Avatar: 'avatar',
    Inset: 'inset',
    Main: 'main',
    MainRaw: 'main-raw',
    Icon: 'icon'
} as const;

export type AssetDataKeyEnum = typeof AssetDataKeyEnum[keyof typeof AssetDataKeyEnum];

/**
 * Character data
 * @export
 * @interface CharacterData
 */
export interface CharacterData {
    /**
     * 
     * @type {string}
     * @memberof CharacterData
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterData
     */
    'id': number;
    /**
     * 
     * @type {TypeData}
     * @memberof CharacterData
     */
    'gender': TypeData;
    /**
     * 
     * @type {TypeData}
     * @memberof CharacterData
     */
    'faction': TypeData;
    /**
     * 
     * @type {IndexData}
     * @memberof CharacterData
     */
    'race': IndexData;
    /**
     * 
     * @type {IndexData}
     * @memberof CharacterData
     */
    'character_class': IndexData;
    /**
     * 
     * @type {IndexData}
     * @memberof CharacterData
     */
    'active_spec': IndexData;
    /**
     * 
     * @type {RealmIndexData}
     * @memberof CharacterData
     */
    'realm': RealmIndexData;
    /**
     * 
     * @type {GuildCharacterIndexData}
     * @memberof CharacterData
     */
    'guild': GuildCharacterIndexData;
    /**
     * 
     * @type {number}
     * @memberof CharacterData
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterData
     */
    'experience': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterData
     */
    'achievement_points': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterData
     */
    'last_login_timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterData
     */
    'average_item_level': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterData
     */
    'equipped_item_level': number;
    /**
     * 
     * @type {TitleData}
     * @memberof CharacterData
     */
    'active_title': TitleData;
    /**
     * 
     * @type {CovenantProgressData}
     * @memberof CharacterData
     */
    'covenant_progress': CovenantProgressData;
}
/**
 * Index of character
 * @export
 * @interface CharacterIndexData
 */
export interface CharacterIndexData {
    /**
     * 
     * @type {string}
     * @memberof CharacterIndexData
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterIndexData
     */
    'id': number;
    /**
     * 
     * @type {RealmIndexData}
     * @memberof CharacterIndexData
     */
    'realm': RealmIndexData;
    /**
     * 
     * @type {IndexData}
     * @memberof CharacterIndexData
     */
    'playable_class': IndexData;
    /**
     * 
     * @type {IndexData}
     * @memberof CharacterIndexData
     */
    'playable_race': IndexData;
    /**
     * 
     * @type {TypeData}
     * @memberof CharacterIndexData
     */
    'gender': TypeData;
    /**
     * 
     * @type {TypeData}
     * @memberof CharacterIndexData
     */
    'faction': TypeData;
    /**
     * 
     * @type {number}
     * @memberof CharacterIndexData
     */
    'level': number;
}
/**
 * Character media data
 * @export
 * @interface CharacterMediaData
 */
export interface CharacterMediaData {
    /**
     * 
     * @type {CharacterMediaIndex}
     * @memberof CharacterMediaData
     */
    'character': CharacterMediaIndex;
    /**
     * 
     * @type {string}
     * @memberof CharacterMediaData
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterMediaData
     */
    'bust_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterMediaData
     */
    'render_url'?: string;
    /**
     * 
     * @type {Array<AssetData>}
     * @memberof CharacterMediaData
     */
    'assets'?: Array<AssetData>;
}
/**
 * Character media data
 * @export
 * @interface CharacterMediaIndex
 */
export interface CharacterMediaIndex {
    /**
     * 
     * @type {string}
     * @memberof CharacterMediaIndex
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterMediaIndex
     */
    'id': number;
    /**
     * 
     * @type {RealmIndexData}
     * @memberof CharacterMediaIndex
     */
    'realm': RealmIndexData;
}
/**
 * Covenant progress data
 * @export
 * @interface CovenantProgressData
 */
export interface CovenantProgressData {
    /**
     * 
     * @type {IndexData}
     * @memberof CovenantProgressData
     */
    'chosen_covenant': IndexData;
    /**
     * 
     * @type {number}
     * @memberof CovenantProgressData
     */
    'renown_level': number;
}
/**
 * Gender data
 * @export
 * @interface GenderData
 */
export interface GenderData {
    /**
     * 
     * @type {NameData}
     * @memberof GenderData
     */
    'male': NameData;
    /**
     * 
     * @type {NameData}
     * @memberof GenderData
     */
    'female': NameData;
}
/**
 * Index of guild character
 * @export
 * @interface GuildCharacterIndexData
 */
export interface GuildCharacterIndexData {
    /**
     * 
     * @type {string}
     * @memberof GuildCharacterIndexData
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GuildCharacterIndexData
     */
    'id': number;
    /**
     * 
     * @type {RealmIndexData}
     * @memberof GuildCharacterIndexData
     */
    'realm': RealmIndexData;
    /**
     * 
     * @type {TypeData}
     * @memberof GuildCharacterIndexData
     */
    'faction': TypeData;
}
/**
 * Index of data
 * @export
 * @interface IndexData
 */
export interface IndexData {
    /**
     * Id of the index
     * @type {number}
     * @memberof IndexData
     */
    'id': number;
    /**
     * 
     * @type {NameData}
     * @memberof IndexData
     */
    'name': NameData;
}
/**
 * Different translations
 * @export
 * @interface NameData
 */
export interface NameData {
    /**
     * The locale of English (U.S.)
     * @type {string}
     * @memberof NameData
     */
    'en_US': string;
    /**
     * The locale of mexican Spanish (Mexican)
     * @type {string}
     * @memberof NameData
     */
    'es_MX': string;
    /**
     * The locale of Portuguese (Brazilian)
     * @type {string}
     * @memberof NameData
     */
    'pt_BR': string;
    /**
     * The locale of German
     * @type {string}
     * @memberof NameData
     */
    'de_DE': string;
    /**
     * The locale of English (U.K.)
     * @type {string}
     * @memberof NameData
     */
    'en_GB': string;
    /**
     * The locale of Spanish (Modern)
     * @type {string}
     * @memberof NameData
     */
    'es_ES': string;
    /**
     * The locale of French
     * @type {string}
     * @memberof NameData
     */
    'fr_FR': string;
    /**
     * The locale of Italian
     * @type {string}
     * @memberof NameData
     */
    'it_IT': string;
    /**
     * The locale of Russian
     * @type {string}
     * @memberof NameData
     */
    'ru_RU': string;
    /**
     * The locale of Korean
     * @type {string}
     * @memberof NameData
     */
    'ko_KR': string;
    /**
     * The locale of Chinese (Taiwan/Traditional)
     * @type {string}
     * @memberof NameData
     */
    'zh_TW': string;
    /**
     * The locale of Chinese (Simplified)
     * @type {string}
     * @memberof NameData
     */
    'zh_CN': string;
}
/**
 * Playable class data
 * @export
 * @interface PlayableClassData
 */
export interface PlayableClassData {
    /**
     * Id of the class
     * @type {number}
     * @memberof PlayableClassData
     */
    'id': number;
    /**
     * 
     * @type {NameData}
     * @memberof PlayableClassData
     */
    'name': NameData;
    /**
     * 
     * @type {GenderData}
     * @memberof PlayableClassData
     */
    'gender_name': GenderData;
    /**
     * 
     * @type {IndexData}
     * @memberof PlayableClassData
     */
    'power_type': IndexData;
    /**
     * 
     * @type {Array<IndexData>}
     * @memberof PlayableClassData
     */
    'specializations': Array<IndexData>;
}
/**
 * Playable class/race media data
 * @export
 * @interface PlayableClassRaceMediaData
 */
export interface PlayableClassRaceMediaData {
    /**
     * Id of the class
     * @type {number}
     * @memberof PlayableClassRaceMediaData
     */
    'id': number;
    /**
     * 
     * @type {Array<AssetData>}
     * @memberof PlayableClassRaceMediaData
     */
    'assets': Array<AssetData>;
}
/**
 * Playable race data
 * @export
 * @interface PlayableRaceData
 */
export interface PlayableRaceData {
    /**
     * Id of the race
     * @type {number}
     * @memberof PlayableRaceData
     */
    'id': number;
    /**
     * 
     * @type {NameData}
     * @memberof PlayableRaceData
     */
    'name': NameData;
    /**
     * 
     * @type {GenderData}
     * @memberof PlayableRaceData
     */
    'gender_name': GenderData;
    /**
     * 
     * @type {TypeData}
     * @memberof PlayableRaceData
     */
    'faction': TypeData;
    /**
     * 
     * @type {boolean}
     * @memberof PlayableRaceData
     */
    'is_selectable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlayableRaceData
     */
    'is_allied_race': boolean;
}
/**
 * Playable specilization data
 * @export
 * @interface PlayableSpecializationData
 */
export interface PlayableSpecializationData {
    /**
     * Id of the specilization
     * @type {number}
     * @memberof PlayableSpecializationData
     */
    'id'?: number;
    /**
     * 
     * @type {IndexData}
     * @memberof PlayableSpecializationData
     */
    'playable_class'?: IndexData;
    /**
     * 
     * @type {NameData}
     * @memberof PlayableSpecializationData
     */
    'name'?: NameData;
    /**
     * 
     * @type {GenderData}
     * @memberof PlayableSpecializationData
     */
    'gender_description'?: GenderData;
    /**
     * 
     * @type {TypeData}
     * @memberof PlayableSpecializationData
     */
    'role'?: TypeData;
    /**
     * 
     * @type {Array<PveTalentTiersData>}
     * @memberof PlayableSpecializationData
     */
    'talent_tiers'?: Array<PveTalentTiersData>;
    /**
     * 
     * @type {Array<PvpTalentTiersData>}
     * @memberof PlayableSpecializationData
     */
    'pvp_talents'?: Array<PvpTalentTiersData>;
}
/**
 * Data of wow accounnt
 * @export
 * @interface ProfileAccountData
 */
export interface ProfileAccountData {
    /**
     * Id of the accounnt
     * @type {number}
     * @memberof ProfileAccountData
     */
    'id': number;
    /**
     * 
     * @type {Array<WowAccountData>}
     * @memberof ProfileAccountData
     */
    'wow_accounts': Array<WowAccountData>;
    /**
     * 
     * @type {NameData}
     * @memberof ProfileAccountData
     */
    'name'?: NameData;
}
/**
 * Description of the pve spell
 * @export
 * @interface PveSpellDescritpionData
 */
export interface PveSpellDescritpionData {
    /**
     * 
     * @type {NameData}
     * @memberof PveSpellDescritpionData
     */
    'description'?: NameData;
    /**
     * 
     * @type {NameData}
     * @memberof PveSpellDescritpionData
     */
    'cast_time'?: NameData;
    /**
     * Index of the spell
     * @type {number}
     * @memberof PveSpellDescritpionData
     */
    'column_index'?: number;
}
/**
 * PVE Talent data
 * @export
 * @interface PveTalentData
 */
export interface PveTalentData {
    /**
     * Id of the talent
     * @type {number}
     * @memberof PveTalentData
     */
    'column_index'?: number;
    /**
     * 
     * @type {TalentData}
     * @memberof PveTalentData
     */
    'talent'?: TalentData;
    /**
     * 
     * @type {PveSpellDescritpionData}
     * @memberof PveTalentData
     */
    'spell_tooltip'?: PveSpellDescritpionData;
}
/**
 * PVE Talent tiers data
 * @export
 * @interface PveTalentTiersData
 */
export interface PveTalentTiersData {
    /**
     * Level where the talents are obtained
     * @type {number}
     * @memberof PveTalentTiersData
     */
    'level'?: number;
    /**
     * 
     * @type {Array<PveTalentData>}
     * @memberof PveTalentTiersData
     */
    'talents'?: Array<PveTalentData>;
    /**
     * Id of the talent
     * @type {number}
     * @memberof PveTalentTiersData
     */
    'tier_index'?: number;
}
/**
 * Description of the pvp spell
 * @export
 * @interface PvpSpellDescritpionData
 */
export interface PvpSpellDescritpionData {
    /**
     * 
     * @type {NameData}
     * @memberof PvpSpellDescritpionData
     */
    'description'?: NameData;
    /**
     * 
     * @type {NameData}
     * @memberof PvpSpellDescritpionData
     */
    'cast_time'?: NameData;
}
/**
 * PVP Talent tiers data
 * @export
 * @interface PvpTalentTiersData
 */
export interface PvpTalentTiersData {
    /**
     * 
     * @type {TalentData}
     * @memberof PvpTalentTiersData
     */
    'talent'?: TalentData;
    /**
     * 
     * @type {PvpSpellDescritpionData}
     * @memberof PvpTalentTiersData
     */
    'spell_tooltip'?: PvpSpellDescritpionData;
}
/**
 * Data of realm
 * @export
 * @interface RealmData
 */
export interface RealmData {
    /**
     * Id of the realm
     * @type {number}
     * @memberof RealmData
     */
    'id': number;
    /**
     * 
     * @type {IndexData}
     * @memberof RealmData
     */
    'region': IndexData;
    /**
     * 
     * @type {NameData}
     * @memberof RealmData
     */
    'name': NameData;
    /**
     * 
     * @type {NameData}
     * @memberof RealmData
     */
    'category': NameData;
    /**
     * Locale of the realm
     * @type {string}
     * @memberof RealmData
     */
    'locale': string;
    /**
     * Timezone of the realm
     * @type {string}
     * @memberof RealmData
     */
    'timezone': string;
    /**
     * 
     * @type {TypeData}
     * @memberof RealmData
     */
    'type': TypeData;
    /**
     * Is true if the realm is a tournament realm
     * @type {boolean}
     * @memberof RealmData
     */
    'is_tournament': boolean;
    /**
     * Slug of the realm
     * @type {string}
     * @memberof RealmData
     */
    'slug': string;
}
/**
 * Index of realm
 * @export
 * @interface RealmIndexData
 */
export interface RealmIndexData {
    /**
     * Id of the index
     * @type {number}
     * @memberof RealmIndexData
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RealmIndexData
     */
    'slug': string;
    /**
     * 
     * @type {NameData}
     * @memberof RealmIndexData
     */
    'name': NameData;
}
/**
 * Talent data
 * @export
 * @interface TalentData
 */
export interface TalentData {
    /**
     * Id of the talent
     * @type {number}
     * @memberof TalentData
     */
    'id'?: number;
    /**
     * 
     * @type {NameData}
     * @memberof TalentData
     */
    'name'?: NameData;
}
/**
 * Data of character title
 * @export
 * @interface TitleData
 */
export interface TitleData {
    /**
     * 
     * @type {NameData}
     * @memberof TitleData
     */
    'name': NameData;
    /**
     * 
     * @type {number}
     * @memberof TitleData
     */
    'id': number;
    /**
     * 
     * @type {NameData}
     * @memberof TitleData
     */
    'display_string': NameData;
}
/**
 * Faction data
 * @export
 * @interface TypeData
 */
export interface TypeData {
    /**
     * 
     * @type {string}
     * @memberof TypeData
     */
    'type': string;
    /**
     * 
     * @type {NameData}
     * @memberof TypeData
     */
    'name': NameData;
}
/**
 * Data of wow accounnt
 * @export
 * @interface WowAccountData
 */
export interface WowAccountData {
    /**
     * Id of the accounnt
     * @type {number}
     * @memberof WowAccountData
     */
    'id': number;
    /**
     * 
     * @type {Array<CharacterIndexData>}
     * @memberof WowAccountData
     */
    'characters': Array<CharacterIndexData>;
}

/**
 * AccountProfileApi - axios parameter creator
 * @export
 */
export const AccountProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Account Profile Summary
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getUserProfile', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getUserProfile', 'region', region)
            const localVarPath = `/profile/user/wow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountProfileApi - functional programming interface
 * @export
 */
export const AccountProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Account Profile Summary
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileAccountData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(namespace, region, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountProfileApi - factory interface
 * @export
 */
export const AccountProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountProfileApiFp(configuration)
    return {
        /**
         * Account Profile Summary
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<ProfileAccountData> {
            return localVarFp.getUserProfile(namespace, region, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountProfileApi - object-oriented interface
 * @export
 * @class AccountProfileApi
 * @extends {BaseAPI}
 */
export class AccountProfileApi extends BaseAPI {
    /**
     * Account Profile Summary
     * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountProfileApi
     */
    public getUserProfile(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return AccountProfileApiFp(this.configuration).getUserProfile(namespace, region, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterMediaApi - axios parameter creator
 * @export
 */
export const CharacterMediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a summary of the media assets available for a character (such as an avatar render).
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {string} characterName The lowercase name of the character.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterMedia: async (namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCharacterMedia', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getCharacterMedia', 'region', region)
            // verify required parameter 'realmSlug' is not null or undefined
            assertParamExists('getCharacterMedia', 'realmSlug', realmSlug)
            // verify required parameter 'characterName' is not null or undefined
            assertParamExists('getCharacterMedia', 'characterName', characterName)
            const localVarPath = `/profile/wow/character/{realmSlug}/{characterName}/character-media`
                .replace(`{${"realmSlug"}}`, encodeURIComponent(String(realmSlug)))
                .replace(`{${"characterName"}}`, encodeURIComponent(String(characterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterMediaApi - functional programming interface
 * @export
 */
export const CharacterMediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CharacterMediaApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a summary of the media assets available for a character (such as an avatar render).
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {string} characterName The lowercase name of the character.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterMedia(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterMediaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharacterMedia(namespace, region, realmSlug, characterName, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CharacterMediaApi - factory interface
 * @export
 */
export const CharacterMediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CharacterMediaApiFp(configuration)
    return {
        /**
         * Returns a summary of the media assets available for a character (such as an avatar render).
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {string} characterName The lowercase name of the character.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterMedia(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<CharacterMediaData> {
            return localVarFp.getCharacterMedia(namespace, region, realmSlug, characterName, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CharacterMediaApi - object-oriented interface
 * @export
 * @class CharacterMediaApi
 * @extends {BaseAPI}
 */
export class CharacterMediaApi extends BaseAPI {
    /**
     * Returns a summary of the media assets available for a character (such as an avatar render).
     * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {string} realmSlug The slug of the realm.
     * @param {string} characterName The lowercase name of the character.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMediaApi
     */
    public getCharacterMedia(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return CharacterMediaApiFp(this.configuration).getCharacterMedia(namespace, region, realmSlug, characterName, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterProfileApi - axios parameter creator
 * @export
 */
export const CharacterProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a profile summary for a character.
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {string} characterName The lowercase name of the character.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacter: async (namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCharacter', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getCharacter', 'region', region)
            // verify required parameter 'realmSlug' is not null or undefined
            assertParamExists('getCharacter', 'realmSlug', realmSlug)
            // verify required parameter 'characterName' is not null or undefined
            assertParamExists('getCharacter', 'characterName', characterName)
            const localVarPath = `/profile/wow/character/{realmSlug}/{characterName}`
                .replace(`{${"realmSlug"}}`, encodeURIComponent(String(realmSlug)))
                .replace(`{${"characterName"}}`, encodeURIComponent(String(characterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterProfileApi - functional programming interface
 * @export
 */
export const CharacterProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CharacterProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a profile summary for a character.
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {string} characterName The lowercase name of the character.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacter(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharacter(namespace, region, realmSlug, characterName, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CharacterProfileApi - factory interface
 * @export
 */
export const CharacterProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CharacterProfileApiFp(configuration)
    return {
        /**
         * Returns a profile summary for a character.
         * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {string} characterName The lowercase name of the character.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacter(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<CharacterData> {
            return localVarFp.getCharacter(namespace, region, realmSlug, characterName, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CharacterProfileApi - object-oriented interface
 * @export
 * @class CharacterProfileApi
 * @extends {BaseAPI}
 */
export class CharacterProfileApi extends BaseAPI {
    /**
     * Returns a profile summary for a character.
     * @param {'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {string} realmSlug The slug of the realm.
     * @param {string} characterName The lowercase name of the character.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterProfileApi
     */
    public getCharacter(namespace: 'profile-eu' | 'profile-us' | 'profile-kr' | 'profile-tw' | 'profile-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, characterName: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return CharacterProfileApiFp(this.configuration).getCharacter(namespace, region, realmSlug, characterName, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CovenantApi - axios parameter creator
 * @export
 */
export const CovenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an index of covenants.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCovenantIndex: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCovenantIndex', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getCovenantIndex', 'region', region)
            const localVarPath = `/data/wow/covenant/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns media for a covenant by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} covenantId The ID of the covenant.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCovenantMediaById: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', covenantId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCovenantMediaById', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getCovenantMediaById', 'region', region)
            // verify required parameter 'covenantId' is not null or undefined
            assertParamExists('getCovenantMediaById', 'covenantId', covenantId)
            const localVarPath = `/data/wow/media/covenant/{covenantId}`
                .replace(`{${"covenantId"}}`, encodeURIComponent(String(covenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CovenantApi - functional programming interface
 * @export
 */
export const CovenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CovenantApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an index of covenants.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCovenantIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayCovenantIndexData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCovenantIndex(namespace, region, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns media for a covenant by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} covenantId The ID of the covenant.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCovenantMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', covenantId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayAssetData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCovenantMediaById(namespace, region, covenantId, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CovenantApi - factory interface
 * @export
 */
export const CovenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CovenantApiFp(configuration)
    return {
        /**
         * Returns an index of covenants.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCovenantIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<ArrayCovenantIndexData> {
            return localVarFp.getCovenantIndex(namespace, region, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns media for a covenant by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} covenantId The ID of the covenant.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCovenantMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', covenantId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<ArrayAssetData> {
            return localVarFp.getCovenantMediaById(namespace, region, covenantId, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CovenantApi - object-oriented interface
 * @export
 * @class CovenantApi
 * @extends {BaseAPI}
 */
export class CovenantApi extends BaseAPI {
    /**
     * Returns an index of covenants.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CovenantApi
     */
    public getCovenantIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return CovenantApiFp(this.configuration).getCovenantIndex(namespace, region, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns media for a covenant by ID.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {number} covenantId The ID of the covenant.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CovenantApi
     */
    public getCovenantMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', covenantId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return CovenantApiFp(this.configuration).getCovenantMediaById(namespace, region, covenantId, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayableClassApi - axios parameter creator
 * @export
 */
export const PlayableClassApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a playable class by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} classId The ID of the playable class.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableClassById: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableClassById', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableClassById', 'region', region)
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getPlayableClassById', 'classId', classId)
            const localVarPath = `/data/wow/playable-class/{classId}`
                .replace(`{${"classId"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an index of playable classes.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableClassIndex: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableClassIndex', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableClassIndex', 'region', region)
            const localVarPath = `/data/wow/playable-class/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns media for a playable class by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} classId The ID of the playable class.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableClassMediaById: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableClassMediaById', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableClassMediaById', 'region', region)
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getPlayableClassMediaById', 'classId', classId)
            const localVarPath = `/data/wow/media/playable-class/{classId}`
                .replace(`{${"classId"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayableClassApi - functional programming interface
 * @export
 */
export const PlayableClassApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayableClassApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a playable class by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} classId The ID of the playable class.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableClassById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayableClassData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableClassById(namespace, region, classId, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an index of playable classes.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableClassIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayClassesIndexData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableClassIndex(namespace, region, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns media for a playable class by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} classId The ID of the playable class.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableClassMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayableClassRaceMediaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableClassMediaById(namespace, region, classId, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayableClassApi - factory interface
 * @export
 */
export const PlayableClassApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayableClassApiFp(configuration)
    return {
        /**
         * Returns a playable class by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} classId The ID of the playable class.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableClassById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<PlayableClassData> {
            return localVarFp.getPlayableClassById(namespace, region, classId, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an index of playable classes.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableClassIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<ArrayClassesIndexData> {
            return localVarFp.getPlayableClassIndex(namespace, region, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns media for a playable class by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} classId The ID of the playable class.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableClassMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<PlayableClassRaceMediaData> {
            return localVarFp.getPlayableClassMediaById(namespace, region, classId, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayableClassApi - object-oriented interface
 * @export
 * @class PlayableClassApi
 * @extends {BaseAPI}
 */
export class PlayableClassApi extends BaseAPI {
    /**
     * Returns a playable class by ID.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {number} classId The ID of the playable class.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableClassApi
     */
    public getPlayableClassById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableClassApiFp(this.configuration).getPlayableClassById(namespace, region, classId, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an index of playable classes.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableClassApi
     */
    public getPlayableClassIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableClassApiFp(this.configuration).getPlayableClassIndex(namespace, region, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns media for a playable class by ID.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {number} classId The ID of the playable class.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableClassApi
     */
    public getPlayableClassMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', classId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableClassApiFp(this.configuration).getPlayableClassMediaById(namespace, region, classId, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayableRaceApi - axios parameter creator
 * @export
 */
export const PlayableRaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a playable race by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} raceId The ID of the playable race.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableRaceById: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', raceId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableRaceById', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableRaceById', 'region', region)
            // verify required parameter 'raceId' is not null or undefined
            assertParamExists('getPlayableRaceById', 'raceId', raceId)
            const localVarPath = `/data/wow/playable-race/{raceId}`
                .replace(`{${"raceId"}}`, encodeURIComponent(String(raceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an index of playable races.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableRaceIndex: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableRaceIndex', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableRaceIndex', 'region', region)
            const localVarPath = `/data/wow/playable-race/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayableRaceApi - functional programming interface
 * @export
 */
export const PlayableRaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayableRaceApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a playable race by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} raceId The ID of the playable race.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableRaceById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', raceId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayableRaceData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableRaceById(namespace, region, raceId, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an index of playable races.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableRaceIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayRacesIndexData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableRaceIndex(namespace, region, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayableRaceApi - factory interface
 * @export
 */
export const PlayableRaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayableRaceApiFp(configuration)
    return {
        /**
         * Returns a playable race by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} raceId The ID of the playable race.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableRaceById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', raceId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<PlayableRaceData> {
            return localVarFp.getPlayableRaceById(namespace, region, raceId, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an index of playable races.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableRaceIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<ArrayRacesIndexData> {
            return localVarFp.getPlayableRaceIndex(namespace, region, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayableRaceApi - object-oriented interface
 * @export
 * @class PlayableRaceApi
 * @extends {BaseAPI}
 */
export class PlayableRaceApi extends BaseAPI {
    /**
     * Returns a playable race by ID.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {number} raceId The ID of the playable race.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableRaceApi
     */
    public getPlayableRaceById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', raceId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableRaceApiFp(this.configuration).getPlayableRaceById(namespace, region, raceId, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an index of playable races.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableRaceApi
     */
    public getPlayableRaceIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableRaceApiFp(this.configuration).getPlayableRaceIndex(namespace, region, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayableSpecializationApi - axios parameter creator
 * @export
 */
export const PlayableSpecializationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a playable specialization by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} specId The ID of the playable specialization.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableSpecializationById: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableSpecializationById', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableSpecializationById', 'region', region)
            // verify required parameter 'specId' is not null or undefined
            assertParamExists('getPlayableSpecializationById', 'specId', specId)
            const localVarPath = `/data/wow/playable-specialization/{specId}`
                .replace(`{${"specId"}}`, encodeURIComponent(String(specId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an index of playable specializations.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableSpecializationIndex: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableSpecializationIndex', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableSpecializationIndex', 'region', region)
            const localVarPath = `/data/wow/playable-specialization/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns media for a playable specialization by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} specId The ID of the playable specialization.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableSpecializationMediaById: async (namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getPlayableSpecializationMediaById', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getPlayableSpecializationMediaById', 'region', region)
            // verify required parameter 'specId' is not null or undefined
            assertParamExists('getPlayableSpecializationMediaById', 'specId', specId)
            const localVarPath = `/data/wow/media/playable-specialization/{specId}`
                .replace(`{${"specId"}}`, encodeURIComponent(String(specId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayableSpecializationApi - functional programming interface
 * @export
 */
export const PlayableSpecializationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayableSpecializationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a playable specialization by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} specId The ID of the playable specialization.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableSpecializationById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayableSpecializationData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableSpecializationById(namespace, region, specId, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an index of playable specializations.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableSpecializationIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySpecializationsIndexData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableSpecializationIndex(namespace, region, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns media for a playable specialization by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} specId The ID of the playable specialization.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayableSpecializationMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayableClassRaceMediaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayableSpecializationMediaById(namespace, region, specId, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayableSpecializationApi - factory interface
 * @export
 */
export const PlayableSpecializationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayableSpecializationApiFp(configuration)
    return {
        /**
         * Returns a playable specialization by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} specId The ID of the playable specialization.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableSpecializationById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<PlayableSpecializationData> {
            return localVarFp.getPlayableSpecializationById(namespace, region, specId, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an index of playable specializations.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableSpecializationIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<ArraySpecializationsIndexData> {
            return localVarFp.getPlayableSpecializationIndex(namespace, region, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns media for a playable specialization by ID.
         * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {number} specId The ID of the playable specialization.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayableSpecializationMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<PlayableClassRaceMediaData> {
            return localVarFp.getPlayableSpecializationMediaById(namespace, region, specId, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayableSpecializationApi - object-oriented interface
 * @export
 * @class PlayableSpecializationApi
 * @extends {BaseAPI}
 */
export class PlayableSpecializationApi extends BaseAPI {
    /**
     * Returns a playable specialization by ID.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {number} specId The ID of the playable specialization.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableSpecializationApi
     */
    public getPlayableSpecializationById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableSpecializationApiFp(this.configuration).getPlayableSpecializationById(namespace, region, specId, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an index of playable specializations.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableSpecializationApi
     */
    public getPlayableSpecializationIndex(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableSpecializationApiFp(this.configuration).getPlayableSpecializationIndex(namespace, region, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns media for a playable specialization by ID.
     * @param {'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {number} specId The ID of the playable specialization.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayableSpecializationApi
     */
    public getPlayableSpecializationMediaById(namespace: 'static-eu' | 'static-us' | 'static-kr' | 'static-tw' | 'static-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', specId: number, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return PlayableSpecializationApiFp(this.configuration).getPlayableSpecializationMediaById(namespace, region, specId, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RealmApi - axios parameter creator
 * @export
 */
export const RealmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single realm by slug or ID.
         * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealmBySlug: async (namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getRealmBySlug', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getRealmBySlug', 'region', region)
            // verify required parameter 'realmSlug' is not null or undefined
            assertParamExists('getRealmBySlug', 'realmSlug', realmSlug)
            const localVarPath = `/data/wow/realm/{realmSlug}`
                .replace(`{${"realmSlug"}}`, encodeURIComponent(String(realmSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an index of realms.
         * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealmIndex: async (namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getRealmIndex', 'namespace', namespace)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getRealmIndex', 'region', region)
            const localVarPath = `/data/wow/realm/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthAuthorizationCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuthAuthorizationCode", ["wow.profile"], configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealmApi - functional programming interface
 * @export
 */
export const RealmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealmApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single realm by slug or ID.
         * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealmBySlug(namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealmData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealmBySlug(namespace, region, realmSlug, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an index of realms.
         * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealmIndex(namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayRealmsIndexData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealmIndex(namespace, region, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RealmApi - factory interface
 * @export
 */
export const RealmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealmApiFp(configuration)
    return {
        /**
         * Returns a single realm by slug or ID.
         * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {string} realmSlug The slug of the realm.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealmBySlug(namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<RealmData> {
            return localVarFp.getRealmBySlug(namespace, region, realmSlug, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an index of realms.
         * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
         * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
         * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealmIndex(namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: any): AxiosPromise<ArrayRealmsIndexData> {
            return localVarFp.getRealmIndex(namespace, region, locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealmApi - object-oriented interface
 * @export
 * @class RealmApi
 * @extends {BaseAPI}
 */
export class RealmApi extends BaseAPI {
    /**
     * Returns a single realm by slug or ID.
     * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {string} realmSlug The slug of the realm.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmApi
     */
    public getRealmBySlug(namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', realmSlug: string, locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return RealmApiFp(this.configuration).getRealmBySlug(namespace, region, realmSlug, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an index of realms.
     * @param {'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn'} namespace The namespace to use to locate this document.
     * @param {'eu' | 'us' | 'kr' | 'tw' | 'cn'} region The region of the data to retrieve.
     * @param {'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN'} [locale] The locale to reflect in localized data. (If you don\&#39;t send a value, the API sends you all localized data)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmApi
     */
    public getRealmIndex(namespace: 'dynamic-eu' | 'dynamic-us' | 'dynamic-kr' | 'dynamic-tw' | 'dynamic-cn', region: 'eu' | 'us' | 'kr' | 'tw' | 'cn', locale?: 'en_US' | 'es_MX' | 'pt_BR' | 'de_DE' | 'en_GB' | 'es_ES' | 'fr_FR' | 'it_IT' | 'ru_RU' | 'ko_KR' | 'zh_TW' | 'zh_CN', options?: AxiosRequestConfig) {
        return RealmApiFp(this.configuration).getRealmIndex(namespace, region, locale, options).then((request) => request(this.axios, this.basePath));
    }
}


